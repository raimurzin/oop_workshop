C++ поддерживает следующие преобразования:
# 1. Преобразование в стиле C
Преобразование в стиле C выполняется конвертацию встроенных типов и указателей и имеет два способа описания:
```
    double size1 = (double)a;
    double size2 = double(a)
```
# 2. Преобразование static_cast
Преобразование static_cast служит для преобразования связанных типов:
    1) Преобразования числовых типов
    2) Преобразование указателя/ссылки на производных класс в указатель/ссылку на базовый класс
    3) T* в void* и наоборот
**static_cast не выполняет проверки корректности приведения - эта задача отводится программисту**
# 3. Преобразование const_cast
Преобразование const_cast служит для снятия/добавления константности*  
```
    void f(T const& d) {
        const_cast<T&>(d) = 10;
    }
```
*Преобразование от неконстантных значений к контстантым может выполняться неявным образом.
**Изменение значения, которое изначально было объявлено как const, приводит к неопределённому поведению.**
# 4. Преобразование reinterpret_cast
Преобразование reinterpret_cast служит для преобразования указателей и ссылок на несвязанные типы:
```
    double* b = reinterpret_cast<double*>(malloc(sizeof(double)) * 100);
```
**Это наиболее опасное преобразование, так как оно просто интерпретирует битовое представление одного типа как другой тип, без каких-либо проверок.**
# 5. Преобразование dynamic_cast
Преобразование dynamic_cast используется для безопасного приведения указателей или ссылок в иерархии наследования с проверкой типа во время выполнения.
```
    Base* b = (rand() % 2) ? new Derived1() : new Derived2();
    if (Derived1* d1 = dynamic_cast<Derived1*>(b)) {}
    else if (Derived2* d2 = dynamic_cast<Derived2*>(b)) {}
```
**Для использования dynamic_cast необходимо наличие виртуальных методов**
