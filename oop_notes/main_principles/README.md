В основе объектно-ориентированного программирования лежат четыре основных принципа: 
## 1. Инкапсуляция  
Инкапсуляция — это механизм, который объединяет данные и методы, работающие с этими данными, в одном объекте, и скрывает внутреннюю реализацию от внешнего мира.
Это позволяет контролировать доступ к данным и защищать их от несанкционированного изменения.
## 2. Наследование  
Наследование - это механизм, позволяющий создавать производные классы, расширяя уже существующие.
Производный класс наследует свойства (методы) и методы родительского класса (однако доступ можно получить только для protected, public). *Доступ к методам/полям можно осущестлять через указание пространств имен.*   
Наследование может быть:
- Простым
```
    struct Base {
    };
    struct Derived : <modifier> Base {
    };
```
  
Внутри объекта производного класса хранится экземляр родительского класса (включая все поля и методы, которые находятся в private).
![image](https://github.com/user-attachments/assets/086ea6b0-a8c7-433d-aff1-3bd75c1d1826)

Это позволяет осуществлять приведения между производными и базовыми классами (в обратную сторону не работает) - данные в свою очередь остаются:
```
    Base& l = Derived(...); // Преобразование ссылки производного в ссылку базового
    Base* l = &Derived(...); // Преобразование указателя производного в указатель базового
    Base  l = Derived(...);  // В данном случае вызывается конструктор копирования базовго класса (который принимает уже ссылку на базовый класс)
```

Таким образом, при создании объекта производного класса сначала вызывается конструктор родительского класса. 
**Однако если родительский класс не имеет конструктора без параметров в рамках конструктора производного класса необходимо самоятельно вызывать конструктор базового класса.**
```
    struct Base {
        Base(type1 name1, type2 name2 {}
    };
    struct Derived : Base {
        Derived(type1 name1, type2 name2, type3 name3) : Base(name1, name2), name3(name3) {}
    };
```

- Множественным

```
    struct Unit { ... };
    struct Elf : Unit { ... };
    struct Archer : Unit { ... };
    struct ElfArcher : Elf, Archer { ... };
```
При множественном наследовании представление объекта производного класса складывается из представлений в памяти базовых классов и собственных данных производных класса.
![image](https://github.com/user-attachments/assets/f0604674-bef7-4106-8577-8f8c475ae730)

Заметим, что в данном случае происходит архитектурная ошибка: данные дублируются, соответственно потеря памяти и возможность их рассинхронизации - данная проблема решается с помощью виртуального наследования.

***
Виртуальное наследование - это механизм, который используется для решения проблемы "ромбовидного наследования" (diamond problem) в иерархии классов. Оно гарантирует, что базовый класс будет присутствовать в объекте только один раз, независимо от количества путей наследования.
![image](https://github.com/user-attachments/assets/f719c209-4e5d-4f10-831a-388f56f994f9)

```
    struct Unit { ... };
    struct Elf : virtual Unit { ... };
    struct Archer : virtual Unit { ... };
    struct ElfArcher : Elf, Archer { ... };
```
*Данные в результате имеют следующее расположение в памяти, а доступ к методам и полям осуществляется через таблицу виртуалных методов.*
![image](https://github.com/user-attachments/assets/9ede0a7e-cefb-4c88-bdac-4c95162e8956)


За вызов конструктора и деструктора базового класса отвечает самый низший класс иерархии. Таким образом, при использовании конструкторов с параметрами самый низший должен вызывать конструкторы всех базовых классов (однако важно заметить, что промежуточные должны также вызывать конструкторы базовых классов).

## 3. Полиморфизм
Полиморфизм - это способность объектов разных классов обрабатываться через общий интерфейс.
Полиморфизм может быть:
- Статический
Статический полиморфизм разрешается на этапе компиляции и реализуется с помощью перегрузок функций/методов/операторов. Это означает, что компилятор заранее знает, какой метод или функция будет вызвана.
1. Перегрузка функций/методов - создание функций/методов с одинаковым именем, но с различными входными параметрами. При вызове функции по имени будет произведен поиск наиболее подходящей функции
```
    double square(double d) { return d * d; }
    double square(int d) { return d * d; }
```
*При выполнении перегрузки при наследовании методы базового класса затеняются и при необходимости воспользоваться ими необходимо выполнить:*
```
    struct Base {
        void f(char const* s);
    };
    struct Derived : Base {
        void f(int i);
        using Base::f; // <-----
    };
```

2. Перегрузка операторов - создание операторов для пользовательскх типов (для базовых типов - это невозможно).
Перегрузку операторов можно выполнять внутри и снаружи класса (Если выполнена и снаружи и внутри, то произойдет ошибка компиляции). 
Их различие состоит в том, что определении внутри класса экземпляр, к которому выполняется операция, передается неявным образом; во время определения снаружи класса - необходим еще 1 доп аргумент: константная ссылка на исходный экземпляр.
**Перегрузка операторов внутри классов невозможна, если в качестве 1-го аргумента должен выступать какой-то другой тип (в примере 2). **  
**Перегрузка операторов снаружи классов невозможна для операторов type, [], (), ->, = и операторы приведения **

Рассмотрим синтаксис перегрузки операторов:
1) Арифметические операторы
```
    ClassName operator-(ClassName const& v) {} // Унарный минус снаружи класса
    ClassName operator-(ClassName const& v1, ClassName const& v2) {} // Бинарный плюс снаружи класса

    ClassName operator-() {} // Унарный минус внутри класса
    ClassName operator-(ClassName const& v) {} // Бинарный плюс внутри класса
```
2) Операторы инкремента и декрмента
```
    struct ClassName {
        ClassName& operator++() {} // prefix
        ClassName operator++(int) {} // postfix
        ClassName& operator--() {} // prefix
        ClassName operator--(int) {} // postfix
    };
```
3) Операторы ввода-вывода
```
    struct ClassName {};
    std::istream& operator>>(std::istream& is, ClassName& p) {
        is >> ...;
        return is;
    }
    std::ostream& operator<<(std::ostream& os, ClassName& p) {
        is << ...;
        return os;
    }
```
Таким образом, cin, cout - всего лишь объекты для которых переопределены операторы ввода-вывода.
4) Операторы *, ->
```
    struct ClassName {
        Data& operator*() const { return *data; }
        Data* operator->() const { return data; } // Оператор -> обязан возвращать объект указательного типа
    };
```
*Заметим, что перегрузка операторов может выполняться для параметров с различными типами*
```
    ClassName operator-(ClassName const& v, type d) {} // Вычитание из ClassName объекта встроенного элемента
    ClassName operator-(type d, ClassName const& v) {} // Вычитание из встроенного элемента ClassName объекта
```
5) Операторы приведения
```
    struct ClassName {
        operator type1() const { ... }
        operator type2() const { ... }
    };
```
6) Операторы сравнения
```
    ClassName operator==(ClassName const& a, ClassName const& b) { ... } 
    ClassName operator!=(ClassName const& a, ClassName const& b) { return !(a == b); }
    ClassName operator<(ClassName const& a, ClassName const& b) { ... } // Фактически необходимо определить только его 
    ClassName operator>(ClassName const& a, ClassName const& b) { return b < a; }
    ClassName operator<=(ClassName const& a, ClassName const& b) { return !(b < a); } 
    ClassName operator>=(ClassName const& a, ClassName const& b) { return !(a < b); } 
```
*Правилом хорошего тона является создание всех операторов сравнения при определении хотя бы одного из них*



- Динамический
Динамический полиморфизм разрешается во время выполнения программы и реализуется с помощью виртуальных функций.  
***
Виртуальные функции основываются на переопределении методов - создание методов с одинаковым именем, возвращаемым значением и аргументами в производных классах.
```
    struct Person {
        string name() const { return name; }
    };
    struct Professor : Person {
        string name() const { return "Prof." + Person::name(); }
    };
```
В таком случае при ссылании на базовый класс, то при вызове переопределенной функции будет вызываться реализация базового класса этой функции:
```
    Professor pr("Stroustrup");
    cout << pr.name() << endl; // Prof. Stroustrup
    Person* p = &pr;
    cout << pr.name() << endl; // Stroustrup
```
***

Для того, чтобы вызывались функции объекта, на который мы в действительности ссылаемся необходимо использование виртуальных методов - они описываются с помощью ключевого слова **virtual**:
```
    Professor pr("Stroustrup");
    cout << pr.name() << endl; // Prof. Stroustrup
    Person* p = &pr;
    cout << pr.name() << endl; // Prof. Stroustrup
```

Таким образом, создается полиморфный класс - класс, объекты которого содержат указатель на таблицу виртуальных методов соответствующего класса. 
![image](https://github.com/user-attachments/assets/3cf93ffe-41f2-4110-a92e-4fab0c3d0f8b)

Вызов соответствующего виртуального метода происходит по адресу методы из таблицы, которая заводится для каждого объекта своя (т.е. Person::vptr != Student::vptr)
![image](https://github.com/user-attachments/assets/63e559e0-0630-4f3d-9a7d-cada8adb753b)

**Необходимо создавать виртуальный деструктор, если предполагается использование полиморфизма - так как в противном случае возможны утечки памяти.**  
**Производительность выше при статическом полиморфизме - так как нет накладных расходов на создание таблиц виртуальных функций**

***
Чистые виртуальные методы (pure virtual methods) — это виртуальные функции, которые не имеют реализации в базовом классе и должны быть обязательно переопределены в производных классах. Чистый виртуальный метод объявляется с помощью = 0 в конце объявления функции.
```
    struct Person {
        virtual string occupation() const = 0;
    };
    struct Professor : Person {
        string occupation() const { return "Prof."; }
    };
```
Наличие хотя бы одной чистой виртуальной функции делает класс абстрактным - неспособным к созданию объекта).
*Однако чистые виртуальные методы могут иметь определения, которые расположены снаружи класса - в данном случае считается, что описанное определение функции - функция для выполнения по умолчанию в производных классах*

```
    struct NetworkDevice {
        virtual void send() = 0;
    };
    void NetworkDevice::send() { ... }
    
    struct Router : NetworkDevice {
        void send() {
            NetworkDevice::send();
            ...
        }
    };
```
