В основе объектно-ориентированного программирования лежат четыре основных принципа: 
## 1. Инкапсуляция  
Инкапсуляция — это механизм, который объединяет данные и методы, работающие с этими данными, в одном объекте, и скрывает внутреннюю реализацию от внешнего мира.
Это позволяет контролировать доступ к данным и защищать их от несанкционированного изменения.
## 2. Наследование  
Наследование - это механизм, позволяющий создавать производные классы, расширяя уже существующие.
Производный класс наследует свойства (методы) и методы родительского класса (однако доступ можно получить только для protected, public). 
Наследование может быть:
- .
```
    struct Base {
    };
    struct Derived : <modifier> Base {
    };
```

- Множественным
  
Внутри объекта производного класса хранится экземляр родительского класса (включая все поля и методы, которые находятся в private).
![image](https://github.com/user-attachments/assets/086ea6b0-a8c7-433d-aff1-3bd75c1d1826)

Это позволяет осуществлять приведения между производными и базовыми классами (в обратную сторону не работает) - данные в свою очередь остаются:
```
    Base& l = Derived(...); // Преобразование ссылки производного в ссылку базового
    Base* l = &Derived(...); // Преобразование указателя производного в указатель базового
    Base  l = Derived(...);  // В данном случае вызывается конструктор копирования базовго класса (который принимает уже ссылку на базовый класс)
```

Таким образом, при создании объекта производного класса сначала вызывается конструктор родительского класса. 
**Однако если родительский класс не имеет конструктора без параметров в рамках конструктора производного класса необходимо самоятельно вызывать конструктор базового класса.**
```
    struct Base {
        Base(type1 name1, type2 name2 {}
    };
    struct Derived : Base {
        Derived(type1 name1, type2 name2, type3 name3) : Base(name1, name2), name3(name3) {}
    };
```

## 3. Полиморфизм
Полиморфизм - это способность объектов разных классов обрабатываться через общий интерфейс.
Полиморфизм может быть:
- Статический
Статический полиморфизм разрешается на этапе компиляции и реализуется с помощью перегрузок функций/методов/операторов. Это означает, что компилятор заранее знает, какой метод или функция будет вызвана.
1. Перегрузка функций/методов - создание функций/методов с одинаковым именем, но с различными входными параметрами. При вызове функции по имени будет произведен поиск наиболее подходящей функции
```
    double square(double d) { return d * d; }
    double square(int d) { return d * d; }
```
*При выполнении перегрузки при наследовании методы базового класса затеняются и при необходимости воспользоваться ими необходимо выполнить:*
```
    struct Base {
        void f(char const* s);
    };
    struct Derived : Base {
        void f(int i);
        using Base::f; // <-----
    };
```

2. Перегрузка операторов - создание операторов для пользовательскх типов (для базовых типов - это невозможно).
Перегрузку операторов можно выполнять внутри и снаружи класса (Если выполнена и снаружи и внутри, то произойдет ошибка компиляции). 
Их различие состоит в том, что определении внутри класса экземпляр, к которому выполняется операция, передается неявным образом; во время определения снаружи класса - необходим еще 1 доп аргумент: константная ссылка на исходный экземпляр.
**Перегрузка операторов внутри классов невозможна, если в качестве 1-го аргумента должен выступать какой-то другой тип (в примере 2). **  
**Перегрузка операторов снаружи классов невозможна для операторов type, [], (), ->, = и операторы приведения **

Рассмотрим синтаксис перегрузки операторов:
1) Арифметические операторы
```
    ClassName operator-(ClassName const& v) {} // Унарный минус снаружи класса
    ClassName operator-(ClassName const& v1, ClassName const& v2) {} // Бинарный плюс снаружи класса

    ClassName operator-() {} // Унарный минус внутри класса
    ClassName operator-(ClassName const& v) {} // Бинарный плюс внутри класса
```
2) Операторы инкремента и декрмента
```
    struct ClassName {
        ClassName& operator++() {} // prefix
        ClassName operator++(int) {} // postfix
        ClassName& operator--() {} // prefix
        ClassName operator--(int) {} // postfix
    };
```
3) Операторы ввода-вывода
```
    struct ClassName {};
    std::istream& operator>>(std::istream& is, ClassName& p) {
        is >> ...;
        return is;
    }
    std::ostream& operator<<(std::ostream& os, ClassName& p) {
        is << ...;
        return os;
    }
```
Таким образом, cin, cout - всего лишь объекты для которых переопределены операторы ввода-вывода.
4) Операторы *, ->
```
    struct ClassName {
        Data& operator*() const { return *data; }
        Data* operator->() const { return data; } // Оператор -> обязан возвращать объект указательного типа
    };
```
*Заметим, что перегрузка операторов может выполняться для параметров с различными типами*
```
    ClassName operator-(ClassName const& v, type d) {} // Вычитание из ClassName объекта встроенного элемента
    ClassName operator-(type d, ClassName const& v) {} // Вычитание из встроенного элемента ClassName объекта
```
5) Операторы приведения
```
    struct ClassName {
        operator type1() const { ... }
        operator type2() const { ... }
    };
```
6) Операторы сравнения
```
    ClassName operator==(ClassName const& a, ClassName const& b) { ... } 
    ClassName operator!=(ClassName const& a, ClassName const& b) { return !(a == b); }
    ClassName operator<(ClassName const& a, ClassName const& b) { ... } // Фактически необходимо определить только его 
    ClassName operator>(ClassName const& a, ClassName const& b) { return b < a; }
    ClassName operator<=(ClassName const& a, ClassName const& b) { return !(b < a); } 
    ClassName operator>=(ClassName const& a, ClassName const& b) { return !(a < b); } 
```
*Правилом хорошего тона является создание всех операторов сравнения при определении хотя бы одного из них*



- Динамический
Динамический полиморфизм разрешается во время выполнения программы и реализуется с помощью виртуальных функций.  








**Производительность выше при статическом полиморфизме - так как нет накладных расходов на создание таблиц виртуальных функций**

## 4. Абстракция


***
В рамках ООП существуют еще связнные концепции:
### 1. Абстракция
### 2. Агрегирование
Агрегирование - это включение объекта одного класса в качестве поля в другой. Например: мотоцикл имеет сумку с багажом. 
```
```
**Агрегирование в отличие от наследования устанавливает меньше связей между классами - поэтому если наследование можно заменить на агрегирование, то это необходимо изменить**
*для определения использования агрегирования или наследования следует правило:
"если a имеет b " - агрегацию
"если a является b" - наследование*
### 3. Композиция
